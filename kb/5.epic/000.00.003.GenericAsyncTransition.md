#+#+#+#+markdown
# Generic Async Transition Design

## Goal
Provide a **generic, extensible async transition framework** that supports multiple async operation types (forms, copilot participants, lambdas, HTTP submissions) with a unified lifecycle: start → pause → submit → resume.

## Design Principles
1. **Single resume protocol** for all async operations.
2. **Pluggable operation types** via a registry (host + engine).
3. **Resumable by humans** (UI/commands) and **by machines** (copilot slash commands, HTTP endpoints).
4. **Deterministic token flow**: transitions produce tokens; arcs route tokens to output places.

## Core Data Model
**PendingOp**
- `id`: unique operation id (engine-generated)
- `transitionId`, `inscriptionId`
- `transitionName`: display name (from YAML or derived)
- `transitionDescription`: optional summary text
- `netId`: PNML net id
- `runId`: unique run/session id for multi-instance runs
- `operationType`: enum string (e.g., `form`, `copilot_participant`, `lambda`, `http_endpoint`)
- `status`: `pending|completed|cancelled|failed`
- `resumeToken`: optional external resume key (used by `/submit` or webhook)
- `uiState`: optional serialized UI state (for re-opening forms)
- `metadata`: `createdAt`, `timeout`, `operationParams`
- `outputPlaces`: derived from transition out arcs
- `result`, `error`

**PausedState**
- `enginePaused`: boolean
- `continuationPointer`: internal resume pointer
- `pendingOpsById`: Map<operationId, PendingOp>
- `pendingOpsByToken`: Map<resumeToken, PendingOp>

## VS Code Host Implementation Details
### PendingOpsStore (Extension)
**Purpose**: own the host-side registry for pending async ops so UI, slash commands, and HTTP submissions are consistent.

**Location**: implement as a new module under [editor/src/](editor/src/) and wire in [editor/src/extension.ts](editor/src/extension.ts).

**Responsibilities**:
- Maintain an in-memory `Map<string, PendingOp>` keyed by `operationId` and a `Map<string, string>` for `resumeToken → operationId`.
- Provide derived views for UI: `getPendingSummary()` (count, oldest age), `listPending()` (semantic fields for `/jobs`).
- Lifecycle APIs:
	- `registerStarted(op: PendingOp)`
	- `markCompleted(opId, result)`
	- `markFailed(opId, error)`
	- `markCancelled(opId, reason)`
- Emit events for UI refresh: `onDidChangePendingOps` (used by status bar and notifications).
- Persist minimal metadata in `context.workspaceState` for reload resiliency (`operationId`, `transitionName`, `resumeToken`, `createdAt`, `runId`, `netId`).

### DAP / Run-Bridge Event Schema
The engine emits **custom DAP events** that the extension maps into `PendingOpsStore` and UI surfaces. The run-bridge transports the same schema over WebSocket so run-mode inscriptions can trigger it without an active debug session. The adapter should treat both as identical envelopes.

**Event: asyncOperationStarted**
```json
{
	"type": "event",
	"event": "asyncOperationStarted",
	"body": {
		"operationId": "op-123",
		"operationType": "form|copilot_participant|lambda|http_endpoint",
		"resumeToken": "evo_async_5f2c",
		"transitionId": "t1",
		"transitionName": "Approve Order",
		"transitionDescription": "Human review",
		"inscriptionId": "in_async",
		"netId": "net1",
		"runId": "run-abc",
		"createdAt": 1738185600000,
		"timeoutMs": 300000,
		"uiState": { "schema": "...", "data": { } },
		"metadata": { "origin": "engine" }
	}
}
```

**Event: asyncOperationUpdated** (optional)
```json
{
	"type": "event",
	"event": "asyncOperationUpdated",
	"body": {
		"operationId": "op-123",
		"status": "pending|completed|cancelled|failed",
		"result": { "message": "..." },
		"error": null
	}
}
```

**Run-Bridge WS envelope**
```json
{
	"type": "dapEvent",
	"event": "asyncOperationStarted",
	"body": { "...same as DAP body..." },
	"sessionId": "run-abc"
}
```

### Command Contributions & Activation Events
Command wiring and activation is declared in [editor/package.json](editor/package.json) and implemented in [editor/src/extension.ts](editor/src/extension.ts).

**Commands to add** (beyond existing ones):
- `evolve.listPendingOperations`
- `evolve.resumeForm`
- `evolve.cancelOperation`
- `evolve.submitOperation`

**Activation events**:
- `onCommand:evolve.listPendingOperations`
- `onCommand:evolve.resumeForm`
- `onCommand:evolve.cancelOperation`
- `onCommand:evolve.submitOperation`
- `onLanguage:yaml` (already present for YAML-based entry points)

### Status Bar + Notifications
Implement in [editor/src/extension.ts](editor/src/extension.ts) with a single status bar item and toast notifications:
- Status bar item: `Evolve: Pending (N)` updates on `PendingOpsStore.onDidChangePendingOps`.
- Clicking status bar calls `evolve.listPendingOperations`.
- Notification on `registerStarted()` with action buttons:
	- “Open pending list” → `evolve.listPendingOperations`
	- For forms: “Resume form” → `evolve.resumeForm` with `operationId`.

### Copilot Slash Commands Implementation
Implementation lives in [editor/src/extension.ts](editor/src/extension.ts). The extension registers a chat participant that exposes two slash commands and binds them to `PendingOpsStore`:
- `/jobs`: render `PendingOp` summaries (name, token, runId, remaining time).
- `/submit <token> <message>`: resolve token → `operationId`, then emit `asyncOperationSubmit` with payload `{ message, participantContext }`.

If Copilot models are unavailable, commands should return a short error response and link to the status bar pending list.

### HTTP Submit Endpoint Host Ownership
The extension **owns** the HTTP submit endpoint and run-bridge server. In [editor/src/extension.ts](editor/src/extension.ts), `ensureRunBridge()` spins up `http.Server` and `WebSocketServer` on localhost and exports the connection details via env vars.

**Host rules**:
- Bind to `127.0.0.1` (no external exposure).
- Require `EVOLVE_RUN_BRIDGE_TOKEN` per request.
- Accept `POST /submit` with `{ resumeToken, result }` JSON and dispatch to `PendingOpsStore.submitByToken()`.
- Return `404` for unknown tokens and `409` for already-completed operations.

## Lifecycle Protocol (Generic)
### 1) Start Operation
Triggered when engine encounters an inscription with `execMode: async`.

**Engine → Host** (start event)
```json
{
	"type": "asyncOperationStarted",
	"operationId": "op-123",
	"operationType": "form",
	"resumeToken": "evo_async_5f2c",
	"uiState": { ... },
	"transitionId": "t1",
	"inscriptionId": "in_async",
	"metadata": { "timeout": 300000 }
}
```

### 2) Pause Execution
Engine enters paused state and surfaces status to host (DAP event).

### 3) Submit Operation
Unified submit request for all operation types:
```json
{
	"type": "asyncOperationSubmit",
	"operationId": "op-123",
	"result": { ... },
	"error": null
}
```

### 4) Resume Execution
Engine resolves `PendingOp` by `operationId` or `resumeToken`, updates status, converts `result` to tokens, and fires continuation.

## Copilot Participant Flow (Clarified)
**Key idea**: Copilot interaction is **human-mediated**. The async operation **does not** auto-call Copilot; it emits a resume token and waits for the user to submit through a slash command.

### User Experience
1. Async operation starts → engine generates `resumeToken`.
2. Host shows token to the user in **two ways**:
	 - Debug console output ("Pending op: op-123, token: evo_async_5f2c")
	 - A command `/jobs` in Copilot chat listing pending operations + tokens.
3. User opens Copilot chat, @participant, then submits:
	 `/submit evo_async_5f2c Please analyze this transition.`

### Host Responsibilities
- **`/jobs`**: list pending operations with semantic info:
	- `operationId`, `resumeToken`, `status`
	- `transitionName`, `transitionId`, `transitionDescription`
	- `netId`, `runId` (to disambiguate multiple instances)
	- `createdAt`, `timeout` (time remaining)
- **`/submit <token> <message>`**: parse token → call `asyncOperationSubmit` with result = `{ message, participantContext }`.

### Participant implementation detail (required)
The host must implement a chat participant that is resilient to missing models and follows a strict command-driven flow:

**Participant behavior**:
- Only respond to `/jobs` and `/submit` commands.
- If model access is unavailable, respond with a short error and suggest opening the pending list command.
- Never auto-open chat for restricted topics; respond with a blocked status and a short remediation message.

**Suggested response formats**:
- `/jobs` returns a list of pending items with fields: `transitionName`, `operationId`, `resumeToken`, `runId`, `createdAt`, `timeoutRemaining`.
- `/submit` returns a confirmation and the resolved `operationId` if the token is valid, otherwise an error message.

**Participant context payload**:
When submitting via `/submit`, include:
```json
{
	"message": "<user message>",
	"participantContext": {
		"participantId": "evolve.participant",
		"timestamp": 1738185600000,
		"command": "submit",
		"workspace": { "name": "evolve" }
	}
}
```

### Engine Behavior
- Maps `resumeToken` → `PendingOp` → resume execution.

## Form Flow (Re-openable)
1. Start event includes `uiState` (full form definition).
2. If user closes form, operation remains pending.
3. User re-opens via command: `evolve.resumeForm <operationId>`.
4. Submission triggers `asyncOperationSubmit`.

### Webview Dynamic Form Design (required)
Dynamic form rendering must be hosted in a VS Code webview and powered by a schema-first renderer (see [kb/2.designPattern/dynamicForm.md](kb/2.designPattern/dynamicForm.md)). The webview must operate without dependency on external repositories.

**FormSpec contract** (serialized into `uiState.formSpec`):
```json
{
	"schemaId": "customer",
	"schemaVersion": "1.0.0",
	"value": { "name": "Ada" },
	"model": { "customer": { "name": "Ada" } },
	"bindings": { "name": "$.customer.name" },
	"uiSchema": { "ui:order": ["name", "age"] },
	"rules": [ { "id": "r1", "condition": { "type": "equals", "field": "$.age", "value": 18 }, "action": { "type": "visibility", "field": "$.parentConsent", "visible": false } } ],
	"layout": "auto",
	"readOnly": false,
	"title": "Customer Form",
	"submitLabel": "Submit",
	"cancelLabel": "Cancel"
}
```

**Webview runtime requirements**:
- Render schema-driven form from `formSpec`.
- Support `uiSchema` ordering and widgets.
- Support bindings to an external model via JSONPath when `value` is absent.
- Validate with an AJV-compatible validator and display errors.
- Emit `onChange`, `onValidate`, `onSubmit` events to the extension.
- Persist temporary form state using `vscode.setState()` so refresh does not lose edits.

**Webview ↔ Extension message protocol**:
- `init`: extension → webview with `formSpec` + `operationId`.
- `change`: webview → extension `{ operationId, data }` (optional for live sync).
- `validate`: webview → extension `{ operationId, valid, errors }`.
- `submit`: webview → extension `{ operationId, result }` → extension calls `asyncOperationSubmit`.
- `cancel`: webview → extension `{ operationId, reason }` → extension calls `cancelOperation`.

**Resume UX**:
- `evolve.resumeForm` re-opens webview and re-sends last known `formSpec` + persisted state.
- If `uiState.formSpec` is missing, show a warning and do not attempt to resume.

## Lambda Flow (Automatic)
**Difference vs existing async flow**:
- Existing async (in [kb/5.epic/000.00.002.Sync.Async.Transition.md](kb/5.epic/000.00.002.Sync.Async.Transition.md)) is **inscription-driven**: the inscription returns an `AsyncResult` and the engine registers a pending op.
- **Lambda flow** is **host-driven**: the host executes a named lambda (or worker) **outside** the inscription body and submits the result using the generic submit protocol.

**Summary**:
- `operationType: lambda`
- No external resume. Host runs the lambda, then submits results automatically.

## HTTP Submit Flow
- `operationType: http_endpoint`
- Host exposes an HTTP endpoint.
- Resume payload includes `resumeToken` and `result`.

## Token Flow Clarification
**Correct model**:
- The **transition produces the token(s)** when it resumes.
- **Out arcs determine where tokens go** (output places).
- `result` is **mapped to token content**; arcs determine destination.

## Required VS Code Commands
- `evolve.listPendingOperations`: list `PendingOp`s in a quick-pick
- `evolve.resumeForm <operationId>`: re-open form UI
- `evolve.cancelOperation <operationId>`: cancel and emit error token
- `evolve.submitOperation <operationId> <result>`: manual submit

## Copilot Slash Commands
- `/jobs`: list pending operations and tokens
- `/submit <token> <message>`: submit result by token

## Copilot Policy (Restricted Topics)
- **Recommendation**: remove automatic fallback that opens Copilot UI on restricted topics.
- **Preferred path**: if a topic may be restricted, use **participant flow** so the PNML determines whether and how to handle the content.
- **Host behavior**: return a blocked status in the async result and do not auto-open chat.

## Host UX Surfaces
- **Status bar item** (right bottom): `Evolve: Pending (N)`.
	- Clicking opens a list of pending operations (same data as `/jobs`).
- **Notification center**:
	- On new pending op: toast with action “Open pending list”.
	- For form ops: toast action “Resume form”.
- **Details panel** (optional): shows instructions for participant flow (e.g., `/submit <token> <message>`).

## Security & Validation
- Resume tokens are opaque, single-use, time-bound.
- Host validates token ownership and session.
- Timeouts mark `PendingOp` as failed and emit error tokens.

## Acceptance Criteria
- Async transitions can be resumed via UI, slash commands, or HTTP.
- `/jobs` shows all pending operations and tokens.
- Token content comes from async result; token routing follows out arcs.

# Implementation Strategy
## Epic 1: Pending Operation Registry
- Story: Track operations with semantic metadata for `/jobs` and UI surfaces.
- User stories:
	- As a user, I can list pending ops with `transitionName`, `runId`, and time remaining.
	- As a user, I can disambiguate multiple instances of the same PNML file.

## Epic 2: Copilot Slash Commands
- Story: Add `/jobs` and `/submit` support in the host.
- User stories:
	- As a user, I can view pending ops inside Copilot chat.
	- As a user, I can submit a resume message by token.

## Epic 3: Form Resume UX
- Story: Re-open form UI for pending ops.
- User stories:
	- As a user, I can re-open a closed form by operation id.
	- As a user, I can cancel a pending form.

## Epic 4: Status Bar + Notifications
- Story: Show pending ops in VS Code status bar and notifications.
- User stories:
	- As a user, I can click status bar to list pending ops.
	- As a user, I can jump to the correct resume action from a notification.

## Epic 5: Generic Submit API
- Story: Unified submit protocol for all async operations.
- User stories:
	- As a host, I can submit results by `operationId` or `resumeToken`.
	- As a user, I can resume via HTTP or slash commands.

# Testing Strategy
## Unit Tests (Python engine)
- `PendingOp` stores `transitionName`, `runId`, `netId`.
- `submit_async(opId)` resumes and appends tokens to output places.
- `submit_async(token)` resolves via `resumeToken`.
- Token content is `result`, routing follows out arcs.

## VS Code Automation Tests
- Extend [editor/test/suite/vscode-bridge.test.ts](editor/test/suite/vscode-bridge.test.ts) to assert:
	- `/jobs` renders semantic info (transition name, run id, timeout).
	- `/submit` with valid token resumes and closes pending op.
	- Invalid token returns a failure response.
- Add new tests in [editor/test/suite/async-ops.test.ts](editor/test/suite/async-ops.test.ts):
	- Status bar item updates when pending count changes.
	- Notification action triggers `evolve.listPendingOperations`.
	- `evolve.resumeForm` re-opens UI for `operationType: form`.
	- `evolve.cancelOperation` marks pending op as cancelled and posts error.

## Integration Tests (GenericAsync.evolve.yaml)
- **Use**: [examples/GenericAsync.evolve.yaml](examples/GenericAsync.evolve.yaml) as the source scenario for new VS Code automation test cases that validate async transitions end-to-end.
- **Form flow**: pending op listed, resume via form submission.
- **Participant flow**: `/jobs` → `/submit` resumes.
- **Lambda flow**: host auto-submits result.
- **HTTP flow**: POST with resume token resumes.
