# 000.01.004 Evaluation & Promotion

# Requirements Analysis
- Implement `trace_collector.collect` to normalize runtime outputs into `RunTrace` records (transitionId, inputs, outputs, timings, user interventions, error class).
- Implement `evaluator.evaluate` interface that consumes `RunTrace` and returns either a `no_update` verdict or a new `IdeationSpec` (for promotion or PNML update).
- Implement `pnml_updater.apply` to modify PNML according to evaluator recommendations (replace async transitions with deterministic inscriptions, add tests, add guards).

# Feature Mapping
- New modules: `trace/collector.py`, `evaluator/interface.py`, `pnml_updater.py`.
- Integrates with `vcs` for commit metadata and with `policy` to check promotion criteria.

# System Design
- `RunTrace` schema: JSON object with fields: `run_id`, `transition_results` (list: {transitionId, stdout, stderr, start, end, success, error_type}), `start_time`, `end_time`, `metadata`.
- `evaluator.evaluate(trace) -> { action: 'no_update' | 'suggest_update', ideation_spec?: IdeationSpec, reasons?: [] }`
- `pnml_updater.apply(pnml, evaluation)` performs structural edits and emits a new PNML artifact.

# Implementation Strategy
Stories and tests:

4.1 Story: Implement `trace_collector.collect`
- Tasks:
  - Implement a collector that accepts runtime output and normalizes into `RunTrace`.
- Unit tests:
  - `test_collector_normalizes` (given stdout/stderr and timings returns expected RunTrace structure).
- Test data: `samples/run/trace_001.json`.

4.2 Story: Implement `evaluator.interface` and placeholder evaluator
- Tasks:
  - Define interface and implement a minimal evaluator that returns `{action: 'no_update'}`.
  - Add an adapter to allow injection of ML-based evaluators later.
- Unit tests:
  - `test_evaluator_no_update`.

4.3 Story: Implement `pnml_updater.apply` with deterministic replacement hooks
- Tasks:
  - Implement deterministic replacement rules and apply them when evaluator suggests updates.
- Unit tests:
  - `test_updater_replaces_async_transition` (ensures correct PNML transformation).
- Test data: `samples/pnml/with_async.yaml` and expected `samples/pnml/with_deterministic.yaml`.

4.4 Story: Promotion policy and metrics
- Tasks:
  - Implement promotion thresholds (correctness_rate, latency_variance, user_override_rate) and unit tests that exercise thresholds.
- Unit tests:
  - `test_promotion_decision_made_when_threshold_met`.

# Testing Strategy
- Integration test: `tests/integration/test_evaluate_and_promote.py`
  - Steps:
    1. Use `samples/pnml/with_async.yaml` -> generate code and run with artificial traces that indicate stable behavior for targeted transitions.
    2. Run `trace_collector.collect` to build a `RunTrace`.
    3. Run `evaluator.evaluate` (using a test evaluator that returns `suggest_update` and a replacement ideation).
    4. Run `pnml_updater.apply` and assert the resulting PNML includes deterministic transitions for the promoted elements.
  - Test data: `samples/run/stable_trace_for_transition.json` and `samples/pnml/with_async.yaml`.

---

# Automation
- Add integration test to CI (mark as integration) and ensure VCS actions are mocked for tests, so no real commits are pushed during CI.
