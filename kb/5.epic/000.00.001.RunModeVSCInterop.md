# Epic 000.00.001 - Run Mode VS Code Interop

## Summary
Enable Python inscription code to interoperate with the VS Code extension during **run mode** (non-debug), using a lightweight request channel instead of the DAP debug adapter. This allows `vscode_bridge` calls (e.g., `chat`, `show_message`, `execute_command`, `get_chat_history`) to work when the workflow is executed via `evolve.runNet`.

## Context
- Current implementation only wires `vscode_bridge` during debug sessions (DAP server). In run mode, the Python process is started in a terminal and the bridge is not initialized.
- Example target: [examples/VsCodeInterop.evolve.yaml](examples/VsCodeInterop.evolve.yaml) should be able to call `vscode_bridge.chat(...)` in **run mode** and receive a response.

## Goals
- Provide a run-mode communication channel between Python runtime and the VS Code extension.
- Preserve existing DAP-based debug interop without breaking changes.
- Maintain a synchronous API from the inscription perspective (blocking call), while allowing future async extensions.

## Non-goals
- Redesign of the DAP debug path.
- Full async workflow engine changes (handled in separate epic).

## Design Overview
### Run-mode transport
Use a **local IPC channel** between the Python run process and the VS Code extension:
- Option A (preferred): **WebSocket** server in extension, Python client connects when run mode starts.
- Option B (fallback): **stdin/stdout JSON-RPC** with a wrapper process (harder to integrate with user terminal).

### Lifecycle
1. User triggers `evolve.runNet`.
2. Extension starts a lightweight run-mode bridge server (WebSocket) and spawns the Python run process with connection info in env vars.
3. Python runtime initializes `vscode_bridge` from env (server address + session id).
4. Inscription calls use the run-mode bridge to send requests to the extension.
5. Extension executes the request and returns a response.

### Request/Response Schema
Reuse the same schema as debug bridge:
```json
{
	"id": 1,
	"type": "vscode/chat",
	"params": { "message": "What is 2+2?", "timeout": 30000 }
}
```
Response:
```json
{
	"success": true,
	"result": { "response": "4", "conversationId": "conv-123" }
}
```

### Authentication / Scoping
- Generate a random `RUN_BRIDGE_TOKEN` per run invocation.
- Extension requires the token for all requests.
- Python process receives token via environment variables.

### Configuration
Add VS Code setting:
- `evolve.runBridge.enabled` (boolean, default true)
- `evolve.runBridge.port` (optional, default random ephemeral port)

## Epics, Stories, Tasks
### Epic 1: Run-mode Bridge Transport
**Story 1.1**: Add run-mode bridge server to extension
- Task: Implement WebSocket server in `editor/src/extension.ts`.
- Task: Start server on `evolve.runNet` command.
- Task: Enforce `RUN_BRIDGE_TOKEN` authentication.

**Story 1.2**: Add run-mode bridge client in Python
- Task: Implement a WebSocket client in `enginepy/vscode_bridge.py` when `RUN_BRIDGE_ADDR` env is set.
- Task: Route `_send_request` to run-mode transport when debug bridge is not initialized.

### Epic 2: Run-mode Process Integration
**Story 2.1**: Pass connection info to run process
- Task: Modify `evolve.runNet` to include env vars:
	- `EVOLVE_RUN_BRIDGE_ADDR`
	- `EVOLVE_RUN_BRIDGE_TOKEN`
	- `EVOLVE_RUN_BRIDGE_SESSION`

**Story 2.2**: Graceful shutdown
- Task: Stop bridge server when process exits or when run session ends.

### Epic 3: Compatibility + Backwards Safety
**Story 3.1**: Preserve debug DAP bridge
- Task: Ensure debug sessions still use DAP customRequest path.

**Story 3.2**: Fallback behavior
- Task: If no bridge available in run mode, raise clear RuntimeError.

## API Changes
Python `vscode_bridge` additions:
- Auto-initialize run-mode bridge if env vars exist.
- Optional `vscode_bridge.is_available()` helper.

## Testing Strategy
### Unit
- `enginepy/tests/test_run_bridge_client.py` to validate request serialization and timeout handling.

### Integration
- Extension test: start run session and assert bridge server receives a request.
- End-to-end: use `VsCodeInterop.evolve.yaml` in run mode and confirm response printed.

### Manual
- Run `evolve.runNet` on `VsCodeInterop.evolve.yaml` and verify:
	- VS Code message appears
	- Chat response is printed
	- No crashes if Copilot unavailable

## Acceptance Criteria
- Run mode can call `vscode_bridge.chat` and receive response.
- Run mode can call `vscode_bridge.show_message`.
- Debug mode remains unchanged and works.
- Errors are clear when bridge is unavailable.

## Open Questions
- Should run-mode bridge be persistent across runs or per run invocation? Yes, if we don't need to maintain stateful info across runs.
- Should run-mode bridge allow only the spawned process or multiple clients? multiple clients

## Discussion: Value of DAP-based Interop
Potential value of keeping DAP-based interop:
- **Debug-session context**: DAP already owns pause/step/stack context; bridge calls can be aligned to debugging state.
- **No extra server**: avoids opening a separate socket server when debugging.
- **Stability for debug use-cases**: if WebSocket bridge fails, debug-only interop remains available.

