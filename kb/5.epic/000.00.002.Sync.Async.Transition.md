# Requirements Analysis
- Add async/sync execution modes for inscriptions without breaking current sync behavior.
- Allow inscription results (e.g., `response` from `vscode_bridge.chat`) to become tokens that flow to output places.
- Support pausing workflow execution (non-blocking) when async ops are running, and resume when results return.
- Ensure debug/run modes handle async transitions predictably with clear state and error handling.
- Maintain deterministic transition semantics and preserve existing synchronous guard/expression behavior.

# Feature Mapping
- **Existing**: PNML YAML parsing (inscriptions, transitions, arcs), Python runtime execution, DAP server, VS Code bridge.
- **Needed (new)**:
  - Async inscription mode: `mode: async|sync` or `kind: expression_async` (explicit).
  - Async execution runtime state (pending operations, resume tokens).
  - Token production from inscription return values.
  - DAP/engine “pause and resume” semantics for async operations.

# System Design
- **YAML model**: Extend inscription schema to include `execMode: "sync"|"async"` (default: sync).
- **Runtime data model**:
  - `PendingOp`: { id, transitionId, inscriptionId, outputPlaces, status, result, error }
  - `PausedState`: engine paused flag + continuation pointer.
- **Execution flow**:
  1. On transition firing, execute all sync guards/expressions as today.
  2. If an async inscription is encountered:
     - Start async operation and register `PendingOp`.
     - Pause workflow execution (engine enters suspended state).
     - Return control to host (DAP/runner) with a “paused” event.
  3. When async completes:
     - Convert `result` into token(s).
     - Resume engine, push tokens to output arcs, continue execution.
- **Token mapping**:
  - Default: `result` becomes a single token for all output places.
  - Optional: allow inscription to return `{tokensByPlace: {placeId: token}}` for targeted outputs.
- **Bridge integration**:
  - Add async API in `vscode_bridge` (e.g., `chat_async` returning a handle), or
  - Allow `vscode_bridge.chat` to be used in async inscriptions with a Future-like wrapper (engine awaits via callback).
- **DAP/Host**:
  - Emit DAP event `customRequest` for async call.
  - New event types: `enginePaused`, `engineResumed`, `asyncCompleted`.

# Implementation Strategy
**Epic 1: YAML & Registry**
- Story: Extend inscription schema with `execMode`.
- Tasks:
  - Update parser to capture `execMode` into Inscription.
  - Update codegen to annotate async inscriptions.
- Deliverable: Parser + codegen support for async attribute.

**Epic 2: Runtime Async Execution**
- Story: Add async execution pipeline.
- Tasks:
  - Add `PendingOp` registry in engine.
  - Execute async inscriptions by registering pending and pausing execution.
  - Provide `resume(transitionId, result)` entrypoint.
- Deliverable: Engine can pause/resume around async ops.

**Epic 3: VS Code Bridge Async**
- Story: Async requests via DAP.
- Tasks:
  - Add async request lifecycle in pnml_dap.py and extension.
  - Bridge returns a handle; engine waits for completion event.
- Deliverable: Non-blocking chat execution with resume.

**Epic 4: Token Flow Integration**
- Story: Use async result as token.
- Tasks:
  - Map async result to output places on resume.
  - Support token mapping overrides.
- Deliverable: Tokens from async results flow forward.

# Testing Strategy
- **Unit Tests**
  - Parser captures `execMode`.
  - Engine pauses on async inscription.
  - Resume injects result token into output place(s).
- **Integration Tests**
  - DAP async request -> extension -> response -> engine resume.
  - Mixed sync + async inscriptions in same transition.
- **End-to-End**
  - Example based on `VsCodeInterop.evolve.yaml`: async chat response becomes token and enables next transition.
- **Acceptance Criteria**
  - Workflow does not block (host remains responsive).
  - Async result deterministically resumes execution.
  - Token output matches response payload.

If you want, I can draft a concrete YAML example for the async form and a minimal state machine for pause/resume.