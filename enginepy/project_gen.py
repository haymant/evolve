from __future__ import annotations

import os

from .pnml_parser import parse_pnml


def _sanitize(name: str) -> str:
    return "".join(c if c.isalnum() or c in {"_", "-"} else "_" for c in name)


def generate_python_project(yaml_text: str, out_dir: str, source_name: str = "pnml") -> str:
    net, _places = parse_pnml(yaml_text)
    os.makedirs(out_dir, exist_ok=True)

    module_dir = os.path.join(out_dir, _sanitize(source_name))
    os.makedirs(module_dir, exist_ok=True)

    main_path = os.path.join(module_dir, "main.py")
    init_path = os.path.join(module_dir, "__init__.py")
    inscriptions_path = os.path.join(module_dir, "inscriptions.py")
    local_engine_dir = os.path.join(module_dir, "enginepy")

    with open(init_path, "w", encoding="utf-8") as f:
        f.write("# Auto-generated by EVOLVE LS\n")

    os.makedirs(local_engine_dir, exist_ok=True)
    with open(os.path.join(local_engine_dir, "__init__.py"), "w", encoding="utf-8") as f:
        f.write("# Local engine runtime for generated project\n")
    engine_src_dir = os.path.dirname(__file__)
    for name in (
        "pnml_engine.py",
        "pnml_parser.py",
        "inscription_registry.py",
        "vscode_bridge.py",
        "async_ops.py",
        "pnml_generator.py",
        "pnml_validator.py",
        "ideation_spec.py",
        "selection_applier.py",
        "codegen.py",
        "codegen_adapter.py",
        "runtime.py",
        "runtime_runner.py",
        "trace_collector.py",
        "evaluator.py",
        "evaluator_interface.py",
        "pnml_updater.py",
        "vcs.py",
        "policy/__init__.py",
        "policy/first_version.py",
        "templates/__init__.py",
        "templates/registry.py",
        "trace/__init__.py",
        "trace/collector.py",
    ):
        src_path = os.path.join(engine_src_dir, name)
        dst_path = os.path.join(local_engine_dir, name)
        os.makedirs(os.path.dirname(dst_path), exist_ok=True)
        if os.path.exists(src_path):
            with open(src_path, "r", encoding="utf-8") as src:
                content = src.read()
            with open(dst_path, "w", encoding="utf-8") as dst:
                dst.write(content)

    with open(inscriptions_path, "w", encoding="utf-8") as f:
        f.write("# Auto-generated inscriptions (inline python only)\n\n")
        f.write("from enginepy import vscode_bridge\n")
        f.write("from enginepy.inscription_registry import build_registry_key, register_inscription\n\n")
        # Provide safe imports for commonly referenced helpers so generated
        # functions don't raise NameErrors and static analyzers like Pylance
        # don't report undefined variables.
        f.write("try:\n")
        f.write("    from enginepy import pnml_generator, selection_applier, pnml_validator, codegen, runtime, trace_collector, evaluator, vcs\n")
        f.write("except Exception:\n")
        f.write("    try:\n")
        f.write("        import pnml_generator, selection_applier, pnml_validator, codegen, runtime, trace_collector, evaluator, vcs\n")
        f.write("    except Exception:\n")
        f.write("        pass\n\n")
        pnml_name = net.id or source_name
        for tid, transition in net.transitions.items():
            for ins in transition.inscriptions:
                if ins.language != "python":
                    continue
                code = (ins.code or "").rstrip("\n")
                kind = ins.kind or "inscription"
                name = ins.id or f"{tid}_{kind}"
                func_name = _sanitize(name)
                registry_key = f"{pnml_name}_{tid}_{kind}"
                f.write(f"# {tid} {kind} {name}\n")
                f.write(f"def {func_name}(token=None):\n")
                lines = [line.rstrip() for line in code.splitlines()]
                if kind == "guard" and len(lines) == 1:
                    stmt = lines[0].strip()
                    if stmt.startswith("return "):
                        f.write(f"    {stmt}\n")
                    elif stmt.startswith("print"):
                        f.write(f"    {stmt}\n")
                    else:
                        f.write(f"    return {stmt}\n")
                else:
                    for line in lines:
                        f.write(f"    {line}\n")
                f.write("\n")
                f.write(f"register_inscription(build_registry_key('{pnml_name}', '{tid}', '{kind}'), {func_name})\n\n")

    with open(main_path, "w", encoding="utf-8") as f:
        f.write("import os\n")
        f.write("import sys\n\n")
        f.write("MODULE_DIR = os.path.abspath(os.path.dirname(__file__))\n")
        f.write("if MODULE_DIR not in sys.path:\n")
        f.write("    sys.path.insert(0, MODULE_DIR)\n\n")
        f.write("import inscriptions  # noqa: F401\n")
        f.write("from enginepy.pnml_engine import PNMLEngine, PendingOp\n")
        f.write("from enginepy import vscode_bridge\n")
        f.write("from enginepy.pnml_parser import parse_pnml\n\n")
        f.write("def run(path: str) -> None:\n")
        f.write("    text = open(path, 'r', encoding='utf-8').read()\n")
        f.write("    net, _ = parse_pnml(text)\n")
        f.write("    engine = PNMLEngine(net)\n")
        f.write("    while True:\n")
        f.write("        result = engine.step_once()\n")
        f.write("        if result is None:\n")
        f.write("            break\n")
        f.write("        if isinstance(result, PendingOp) and not result.completed:\n")
        f.write("            token = result.resume_token or 'n/a'\n")
        f.write("            print(f'Paused for async operation: {result.id} type={result.operation_type} token={token}')\n")
        f.write("            if vscode_bridge.is_available():\n")
        f.write("                timeout_ms = None\n")
        f.write("                if result.metadata and isinstance(result.metadata, dict):\n")
        f.write("                    timeout_ms = result.metadata.get('timeout_ms') or result.metadata.get('timeout')\n")
        f.write("                payload = vscode_bridge.wait_for_async_submit(result.resume_token, timeout_ms)\n")
        f.write("                if payload:\n")
        f.write("                    engine.submit_async(resume_token=payload.get('resumeToken') or result.resume_token, result=payload.get('result'), error=payload.get('error'))\n")
        f.write("                    continue\n")
        f.write("            break\n")
        f.write("        if not engine.enabled_transitions():\n")
        f.write("            break\n")
        f.write("    print('Final marking:', engine.marking)\n\n")
        f.write("if __name__ == '__main__':\n")
        f.write("    if len(sys.argv) < 2:\n")
        f.write("        print('Usage: python main.py <path-to-yaml>')\n")
        f.write("        raise SystemExit(2)\n")
        f.write("    run(sys.argv[1])\n")

    return module_dir
